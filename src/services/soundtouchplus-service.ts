// debug logging.
import Debug from 'debug/src/browser.js';
import { DEBUG_APP_NAME } from '../constants';
const debuglog = Debug(DEBUG_APP_NAME + ":soundtouchplus-service");

// lovelace card imports.
import { HomeAssistant } from '../types/home-assistant-frontend/home-assistant';
import { ServiceCallRequest } from '../types/home-assistant-frontend/service-call-request';
import {
  mdiApple,
  mdiAudioInputRca,
  mdiBluetooth,
  mdiMicrophone,
  mdiNumeric1BoxOutline,
  mdiNumeric2BoxOutline,
  mdiNumeric3BoxOutline,
  mdiNumeric4BoxOutline,
  mdiNumeric5BoxOutline,
  mdiNumeric6BoxOutline,
  mdiPandora,
  mdiRadio,
  mdiSpeakerMessage,
  mdiSpotify,
  mdiTelevision,
  mdiVideoInputHdmi
} from '@mdi/js';

// our imports.
import {
  DOMAIN_SOUNDTOUCHPLUS,
  DOMAIN_MEDIA_PLAYER
} from '../constants';
import {
  SERVICE_TURN_OFF,
  SERVICE_TURN_ON,
  SERVICE_SELECT_SOURCE,
  SERVICE_VOLUME_MUTE,
  SERVICE_VOLUME_SET
} from '../services/media-control-service'
import { MediaPlayer } from '../model/media-player';
import { getMdiIconImageUrl } from '../utils/media-browser-utils';
import { getUtcNowTimestamp } from '../utils/utils';
import { CardConfig } from '../types/card-config';
import { IAudioDspControls } from '../types/soundtouchplus/audio-dsp-controls';
import { IAudioProductToneControls } from '../types/soundtouchplus/audio-product-tone-controls';
import { IBass } from '../types/soundtouchplus/bass';
import { IBassCapabilities } from '../types/soundtouchplus/bass-capabilities';
import { IContentItem } from '../types/soundtouchplus/content-item';
import { INavigateResponse } from '../types/soundtouchplus/navigate-response';
import { IPresetList } from '../types/soundtouchplus/preset-list';
import { IRecentList } from '../types/soundtouchplus/recent-list';
import { ISourceList } from '../types/soundtouchplus/source-list';
import { ISupportedUrls } from '../types/soundtouchplus/supported-urls';
import { ISoundTouchDevice } from '../types/soundtouchplus/soundtouch-device';


/** SoundTouchPlus custom services provider class. */
export class SoundTouchPlusService {

  /** Home Assistant instance. */
  private readonly hass: HomeAssistant;

  /** Custom card instance. */
  public readonly card: Element;

  /** Card configuration data. */
  public readonly config: CardConfig;


  /**
   * Initializes a new instance of the class.
   * 
   * @param hass HomeAssistant instance.
   * @param card Parent custom card instance.
   * @param config Card configuration instance.
   */
  constructor(hass: HomeAssistant, card: Element, config: CardConfig) {

    // initialize storage.
    this.hass = hass;
    this.card = card;
    this.config = config;
  }


  /**
   * Calls the specified SoundTouchPlus service, passing it the specified parameters.
   * 
   * @param serviceRequest Service request instance that contains the service to call and its parameters.
  */
  public async CallService(
    serviceRequest: ServiceCallRequest
  ): Promise<void> {

    try {

      if (debuglog.enabled) {
        debuglog("%cCallService - Calling service %s (no response)\n%s",
          "color: orange",
          JSON.stringify(serviceRequest.service),
          JSON.stringify(serviceRequest, null, 2)
        );
      }

      // call the service.
      await this.hass.callService(
        serviceRequest.domain,
        serviceRequest.service,
        serviceRequest.serviceData,
        serviceRequest.target,
      )

    } finally {
    }
  }


  /**
   * Calls the specified SoundTouchPlus service and returns response data that is generated by the
   * service.
   * 
   * @param serviceRequest Service request instance that contains the service to call and its parameters.
   * @returns Response data, in the form of a Record<string, any> (e.g. dictionary).
  */
  public async CallServiceWithResponse(
    serviceRequest: ServiceCallRequest,
  ): Promise<Record<string, any>> {

    try {

      if (debuglog.enabled) {
        debuglog("%cCallServiceWithResponse - Calling service %s (with response)\n%s",
          "color: orange",
          JSON.stringify(serviceRequest.service),
          JSON.stringify(serviceRequest, null, 2)
        );
      }

      //// ensure user is administrator; left this in here in case we need it in the future.
      //if (!this.hass.user.is_admin) {
      //  throw Error("User account \"" + this.hass.user.name + "\" is not an Administrator; execute_script cannot be called by non-administrator accounts");
      //}

      // call the service.
      const serviceResponse = await this.hass.callService(
        serviceRequest.domain,
        serviceRequest.service,
        serviceRequest.serviceData,
        serviceRequest.target,
        undefined,                  // notify on error
        true,                       // return response data
      )

      if (debuglog.enabled) {
        debuglog("%cCallServiceWithResponse - Service %s response:\n%s",
          "color: red",
          JSON.stringify(serviceRequest.service),
          JSON.stringify(serviceResponse.response, null, 2)
        );
      }

      // return the service response data or an empty dictionary if no response data was generated.
      return serviceResponse.response || {};

    }
    finally {
    }
  }


  /**
   * Gets the current audio dsp controls configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param refresh True to query the device for realtime information and refresh the cache; otherwise, False to just return the cached information.
   * @returns A IAudioDspControls object.
  */
  public async GetAudioDspControls(
    player: MediaPlayer,
    refresh: boolean | undefined | null = null,
  ): Promise<IAudioDspControls> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (refresh != null)
        serviceData['refresh'] = refresh;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_audio_dsp_controls',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IAudioDspControls;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Gets the current audio product tone controls configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param refresh True to query the device for realtime information and refresh the cache; otherwise, False to just return the cached information.
   * @returns A IAudioProductToneControls object.
  */
  public async GetAudioProductToneControls(
    player: MediaPlayer,
    refresh: boolean | undefined | null = null,
  ): Promise<IAudioProductToneControls> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (refresh != null)
        serviceData['refresh'] = refresh;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_audio_product_tone_controls',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IAudioProductToneControls;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Gets the current bass capability configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param refresh True to query the device for realtime information and refresh the cache; otherwise, False to just return the cached information.
   * @returns A IAudioProductToneControls object.
  */
  public async GetBassCapabilities(
    player: MediaPlayer,
    refresh: boolean | undefined | null = null,
  ): Promise<IBassCapabilities> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (refresh != null)
        serviceData['refresh'] = refresh;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_bass_capabilities',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IBassCapabilities;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Gets the current bass level configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param refresh True to query the device for realtime information and refresh the cache; otherwise, False to just return the cached information.
   * @returns A IBass object.
  */
  public async GetBassLevel(
    player: MediaPlayer,
    refresh: boolean | undefined | null = null,
  ): Promise<IBass> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (refresh != null)
        serviceData['refresh'] = refresh;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_bass_level',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IBass;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Gets SoundTouch device information.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @returns A ISoundTouchDevice object.
  */
  public async GetDeviceInfo(
    player: MediaPlayer,
  ): Promise<ISoundTouchDevice> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_device_info',
        serviceData: serviceData
      };

      // for testing device info errors.
      //if (player.id.endsWith("bose_st10_1"))
      //  throw new Error("TEST TODO REMOVEME GetDeviceInfo main card exception ...")

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as ISoundTouchDevice;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Retrieves the list of sources defined to the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @returns A ISourceList object.
  */
  public async GetSourceList(
    player: MediaPlayer,
  ): Promise<ISourceList> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_source_list',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as ISourceList;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // process all items returned.
      if ((responseObj != null) && (responseObj.SourceItems != null)) {

        // left this here in case we want to add hidden devices to integration.
        //// remove source items that are hidden (based on SoundTouchPlus config options);
        //// we have to do this in reverse order, due to iteration of the array.
        //for (let i = responseObj.SourceItems.length - 1; i >= 0; i--) {
        //  if (source_list_hide?.includes(responseObj.SourceItems[i].Source?.toLowerCase())) {
        //    responseObj.SourceItems.splice(i, 1);
        //  }
        //}

        // set ContainerArt property based on device type.
        responseObj.SourceItems.forEach(item => {
          // set ContainerArt path using mdi icons for common sources.
          const sourceCompare = (item.Source || "").toLocaleLowerCase();
          if (sourceCompare.startsWith('airplay')) {
            item.image_url = getMdiIconImageUrl(mdiApple);
          } else if (sourceCompare.startsWith('pandora')) {
            item.image_url = getMdiIconImageUrl(mdiPandora);
          } else if (sourceCompare.startsWith('spotify')) {
            item.image_url = getMdiIconImageUrl(mdiSpotify);
          } else if (sourceCompare.startsWith('tunein')) {
            item.image_url = getMdiIconImageUrl(mdiRadio);
          } else if (sourceCompare.startsWith('alexa')) {
            item.image_url = getMdiIconImageUrl(mdiMicrophone);
          } else if (sourceCompare.startsWith('bluetooth')) {
            item.image_url = getMdiIconImageUrl(mdiBluetooth);
          } else if (sourceCompare.startsWith('notification')) {
            item.image_url = getMdiIconImageUrl(mdiSpeakerMessage);
          } else if (sourceCompare.startsWith('product(hdmi')) {
            item.image_url = getMdiIconImageUrl(mdiVideoInputHdmi);
          } else if (sourceCompare.startsWith('product(tv')) {
            item.image_url = getMdiIconImageUrl(mdiTelevision);
          } else {
            item.image_url = getMdiIconImageUrl(mdiAudioInputRca);
          }
        })
      }

      // trace.
      if (debuglog.enabled) {
        debuglog("%cCallServiceWithResponse - Service %s response (trimmed):\n%s",
          "color: orange",
          JSON.stringify(serviceRequest.service),
          JSON.stringify(responseObj, null, 2)
        );
      }

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Gets the supported urls configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param refresh True to query the device for realtime information and refresh the cache; otherwise, False to just return the cached information.
   * @returns A ISupportedUrls object.
  */
  public async GetSupportedUrls(
    player: MediaPlayer,
    refresh: boolean | undefined | null = null,
  ): Promise<ISupportedUrls> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (refresh != null)
        serviceData['refresh'] = refresh;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'get_supported_urls',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as ISupportedUrls;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = getUtcNowTimestamp();

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Retrieves the list of stored stations from the specified music service(e.g. PANDORA, etc).
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param source Music service source to navigate(e.g. 'PANDORA', etc); the value is case -sensitive, and should normally be UPPER case.
   * @param source_account Music service source account (e.g. the music service user-id). Default is none.
   * @param sort_type Sort type used by the Music Service to sort the returned items by; the value is case -sensitive.  valid values are 'stationName' and 'dateCreated'.
   * @returns A INavigateResponse object.
  */
  public async MusicServiceStationList(
    player: MediaPlayer,
    source: string,
    source_account: string,
    sort_type: string | undefined | null = null,
  ): Promise<INavigateResponse> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
        source: source,
        source_account: source_account,
      };

      // update service data parameters (with optional parameters).
      if (sort_type)
        serviceData['sort_type'] = sort_type;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'musicservice_station_list',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as INavigateResponse;

      // set the LastUpdatedOn value to epoch (number of seconds), as the
      // service does not provide this field (but we need it for media list processing).
      responseObj.LastUpdatedOn = Date.now() / 1000

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Calls the SoundTouchPlusService PlayerMediaPlayContext / PlayerMediaPlayTracks method to play media.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param mediaItem Media Browser item that contains media content details to play.  
   */
  public async PlayContentItem(
    player: MediaPlayer,
    mediaItem: IContentItem | undefined,
  ): Promise<void> {

    // validations.
    if (!player) {
      throw new Error("Media player argument was not supplied to the PlayMediaBrowserItem service.")
    }
    if (!mediaItem) {
      throw new Error("Media browser item argument was not supplied to the PlayMediaBrowserItem service.");
    }

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
        source: mediaItem.Source,
        is_presetable: mediaItem.IsPresetable,
      };

      // update service data parameters (with optional parameters).
      if (mediaItem.Name)
        serviceData['name'] = mediaItem.Name;
      if (mediaItem.SourceAccount)
        serviceData['source_account'] = mediaItem.SourceAccount;
      if (mediaItem.TypeValue)
        serviceData['item_type'] = mediaItem.TypeValue;
      if (mediaItem.Location)
        serviceData['location'] = mediaItem.Location;
      if (mediaItem.ContainerArt)
        serviceData['container_art'] = mediaItem.ContainerArt;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'play_contentitem',
        serviceData: serviceData
      };

      // call the service.
      await this.CallService(serviceRequest);

    }
    catch (error) {

      throw new Error("Cannot play media item: " + (error as Error).message);

    }
  }


  /**
   * Retrieves the list of presets defined to the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param include_empty_slots - True to include ALL preset slots (both empty and set); otherwise, False (default) to only include preset slots that have been set.
   * @returns A IPresetList object.
  */
  public async PresetList(
    player: MediaPlayer,
    include_empty_slots: boolean | undefined | null = false,
  ): Promise<IPresetList> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (include_empty_slots)
        serviceData['include_empty_slots'] = include_empty_slots;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'preset_list',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IPresetList;

      // set ContainerArt property for open / empty preset items.
      if (responseObj != null) {
        responseObj.Presets?.forEach(item => {
          if (item.ContentItem) {
            if (item.ContentItem?.Name == 'empty preset') {
              const presetId = item.PresetId;
              let image_url: string | undefined = undefined;
              if (presetId == 1) {
                image_url = getMdiIconImageUrl(mdiNumeric1BoxOutline);
              } else if (presetId == 2) {
                image_url = getMdiIconImageUrl(mdiNumeric2BoxOutline);
              } else if (presetId == 3) {
                image_url = getMdiIconImageUrl(mdiNumeric3BoxOutline);
              } else if (presetId == 4) {
                image_url = getMdiIconImageUrl(mdiNumeric4BoxOutline);
              } else if (presetId == 5) {
                image_url = getMdiIconImageUrl(mdiNumeric5BoxOutline);
              } else if (presetId == 6) {
                image_url = getMdiIconImageUrl(mdiNumeric6BoxOutline);
              }
              item.ContentItem.ContainerArt = image_url;
            }
          }
        })
      }

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Retrieves the list of recents defined to the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @returns A IRecentList object.
  */
  public async RecentList(
    player: MediaPlayer,
  ): Promise<IRecentList> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'recent_list',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IRecentList;

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Retrieves the cached list of recents defined to the file system.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @returns A IRecentList object.
  */
  public async RecentListCache(
    player: MediaPlayer,
  ): Promise<IRecentList> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'recent_list_cache',
        serviceData: serviceData
      };

      // call the service, and return the response.
      const response = await this.CallServiceWithResponse(serviceRequest);

      // convert response to an object type.
      const responseObj = response as IRecentList;

      // return results to caller.
      return responseObj;

    } finally {
    }
  }


  /**
   * Simulates the press and release of a key on the SoundTouch device remote control.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param key_id SoundTouch remote control key identifier (e.g. "PRESET_1", "MUTE", etc).  Note that some keys on the SoundTouch remote control are not sent to the SoundTouch device, and therefore are not supported by this service.
   * @param key_state SoundTouch remote control key state.  Most keys will use 'both' for state; the 'PRESET_n' key ids use 'press' to store a preset, and 'release' to select (or play) a preset.
  */
  public async RemoteKeyPress(
    player: MediaPlayer,
    key_id: string,
    key_state: string | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
        key_id: key_id,
      };

      // update service data parameters (with optional parameters).
      if (key_state)
        serviceData['key_state'] = key_state;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'remote_keypress',
        serviceData: serviceData
      };

      // call the service.
      await this.CallService(serviceRequest);

    } finally {
    }
  }


  /**
   * Sets the current audio dsp controls configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param audio_mode Audio mode value (e.g. "AUDIO_MODE_NORMAL", "AUDIO_MODE_DIALOG", etc).
   * @param video_sync_audio_delay Video syncronization audio delay value (in milliseconds). Suggested range is 0 - 250ms, in increments of 10.
  */
  public async SetAudioDspControls(
    player: MediaPlayer,
    audio_mode: string | undefined | null = null,
    video_sync_audio_delay: number | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (audio_mode != null)
        serviceData['audio_mode'] = audio_mode;
      if (video_sync_audio_delay != null)
        serviceData['video_sync_audio_delay'] = video_sync_audio_delay;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'set_audio_dsp_controls',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    } finally {
    }
  }


  /**
   * Sets the current audio product tone controls configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param bass_level Bass level to set, usually in the range of -100 (low) to 100 (high).
   * @param treble_level Treble level to set, usually in the range of -100 (low) to 100 (high).
  */
  public async SetAudioProductToneControls(
    player: MediaPlayer,
    bass_level: number | undefined | null = null,
    treble_level: number | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (bass_level != null)
        serviceData['bass_level'] = bass_level;
      if (treble_level != null)
        serviceData['treble_level'] = treble_level;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'set_audio_product_tone_controls',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    } finally {
    }
  }


  /**
   * Sets the current bass level configuration of the device.
   * 
   * @param player SoundTouchPlus MediaPlayer instance that will process the request.
   * @param level Bass level to set, usually in the range of -9 (low) to 0 (high).
  */
  public async SetBassLevel(
    player: MediaPlayer,
    level: number | undefined | null = null,
  ): Promise<void> {

    try {

      // create service data (with required parameters).
      const serviceData: { [key: string]: any } = {
        entity_id: player.id,
      };

      // update service data parameters (with optional parameters).
      if (level != null)
        serviceData['level'] = level;

      // create service request.
      const serviceRequest: ServiceCallRequest = {
        domain: DOMAIN_SOUNDTOUCHPLUS,
        service: 'set_bass_level',
        serviceData: serviceData
      };

      // call the service (no response).
      await this.CallService(serviceRequest);

    } finally {
    }
  }


  /** ======================================================================================
   * The following are base MediaPlayerEntity methods.
   * ====================================================================================== 
  */

  /**
   * Selects the given source device.
   * 
   * @param player MediaPlayer instance that will process the request.
   * @param source Source to select.
  */
  public async select_source(
    player: MediaPlayer,
    source: string | undefined | null = null,
  ): Promise<void> {

    // create service data (with required parameters).
    const serviceData: { [key: string]: any } = {
      entity_id: player.id,
    };

    if (source)
      serviceData['source'] = source;

    // create service request.
    const serviceRequest: ServiceCallRequest = {
      domain: DOMAIN_MEDIA_PLAYER,
      service: SERVICE_SELECT_SOURCE,
      serviceData: serviceData
    }

    // call the service (no response).
    await this.CallService(serviceRequest);

  }


  /**
   * Turns off the player.
   * 
   * @param player MediaPlayer instance that will process the request.
  */
  public async turn_off(
    player: MediaPlayer,
  ): Promise<void> {

    // create service data (with required parameters).
    const serviceData: { [key: string]: any } = {
      entity_id: player.id,
    };

    // create service request.
    const serviceRequest: ServiceCallRequest = {
      domain: DOMAIN_MEDIA_PLAYER,
      service: SERVICE_TURN_OFF,
      serviceData: serviceData
    }

    // call the service (no response).
    await this.CallService(serviceRequest);

  }


  /**
   * Turns on the player.
   * 
   * @param player MediaPlayer instance that will process the request.
  */
  public async turn_on(
    player: MediaPlayer,
  ): Promise<void> {

    // create service data (with required parameters).
    const serviceData: { [key: string]: any } = {
      entity_id: player.id,
    };

    // create service request.
    const serviceRequest: ServiceCallRequest = {
      domain: DOMAIN_MEDIA_PLAYER,
      service: SERVICE_TURN_ON,
      serviceData: serviceData
    }

    // call the service (no response).
    await this.CallService(serviceRequest);

  }


  /**
   * Mutes / unmutes the player volume.
   * 
   * @param player MediaPlayer instance that will process the request.
   * @param muteVolume True to mute the volume; otherwise, False to unmute the volume.
   */
  public async volume_mute(player: MediaPlayer, muteVolume: boolean) {

    // create service request.
    const serviceRequest: ServiceCallRequest = {
      domain: DOMAIN_MEDIA_PLAYER,
      service: SERVICE_VOLUME_MUTE,
      serviceData: {
        entity_id: player.id,
        is_volume_muted: muteVolume,
      }
    };

    // call the service.
    await this.CallService(serviceRequest);
  }


  /**
   * Toggles the volume mute status of the player; 
   * if muted, then it will be unmuted;
   * if unmuted, then it will be muted;
   * 
   * @param player MediaPlayer instance that will process the request.
   */
  public async volume_mute_toggle(player: MediaPlayer) {

    const muteVolume = !player.isMuted();
    await this.volume_mute(player, muteVolume);
  }


  /**
   * Sets the player volume.
   * 
   * @param player MediaPlayer instance that will process the request.
   * @param volumePercent Volume level to set, expressed as a percentage (e.g. 1 - 100).
   */
  public async volume_set(player: MediaPlayer, volumePercent: number) {

    // convert volume level to HA float value.
    const volumeLevel = volumePercent / 100;

    // create service request.
    const serviceRequest: ServiceCallRequest = {
      domain: DOMAIN_MEDIA_PLAYER,
      service: SERVICE_VOLUME_SET,
      serviceData: {
        entity_id: player.id,
        volume_level: volumeLevel,
      }
    };

    // call the service.
    await this.CallService(serviceRequest);

  }

}
